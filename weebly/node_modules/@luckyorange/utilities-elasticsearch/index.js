const pkg = require('./package.json')
const Elasticsearch = require('elasticsearch')
const { Client } = require('@elastic/elasticsearch')
const got = require('got')
const validateSchema = require('./schema')

// Ensure ENV endpoint is in the correct structure
let SERVICE_ENDPOINT = process.env.LO_ELASTICSEARCH_ENDPOINT
if (SERVICE_ENDPOINT && SERVICE_ENDPOINT.endsWith('/')) {
  SERVICE_ENDPOINT = SERVICE_ENDPOINT.slice(0, -1)
}

// Automatically handle redirecting local
if (process.env.LOCAL) {
  SERVICE_ENDPOINT = 'http://localhost:8080'
}

const API = {
  /**
   * Elasticsearch clients for all available endpoint keys.
   * @type {Object}
   */
  clients: null,

  /**
   * Elassandra clients for all available endpoint keys.
   * Must first be initialized by getElassandraClients().
   * TODO: Merge this in with default clients when new app is prod.
   * @type {Object}
   */
  elassandraClients: null,

  /**
   * Returns an object containing elasticsearch clients. Generated from
   * LO_EL_ENDPOINT env variables.
   * @param  {String} options Options to pass to Elasticsearch client
   * @return {Object} Object containing ES clients
   */
  getElassandraClients (options = {}) {
    let clients = {}
    Object.keys(process.env).forEach(key => {
      if (key.indexOf('LO_EL_ENDPOINT') === -1) return
      const value = process.env[key]

      const endpoint = key.split('ENDPOINT_')[1]
      let config = Object.assign({}, {
        requestTimeout: 60000
      }, JSON.parse(value), options)

      clients[endpoint] = new Client(config)
    })

    API.elassandraClients = clients
    return clients
  },

  /**
   * Returns an object containing elasticsearch clients. Generated from
   * LO_ES_ENDPOINT env variables.
   * @param  {String} options Options to pass to Elasticsearch client
   * @return {Object} Object containing ES clients
   */
  getElasticsearchClients (options = {}) {
    let clients = {}
    Object.keys(process.env).forEach(key => {
      if (key.indexOf('LO_ES_ENDPOINT') === -1) return
      const value = process.env[key]

      const endpoint = key.split('ENDPOINT_')[1]
      const config = Object.assign({}, {
        apiVersion: '5.3',
        log: 'error',
        requestTimeout: 60000
      }, JSON.parse(value), options)

      clients[endpoint] = new Elasticsearch.Client(config)
    })

    API.clients = clients
    return clients
  },

  /**
   * Makes a request to our internal Elasticsearch HTTP service.
   * @param  {Object} options
   * @param  {String} options.action      create, delete, lookup, search, update
   * @param  {Object} options.body        Request body to send
   * @param  {String} options.endpointKey Account endpoint key
   * @param  {String} options.id          ID used for certain actions
   * @param  {String} options.siteId      Site ID to scope data to
   * @param  {String} options.client      Client type to talk to
   * @return {Promise}
   */
  request (options = {}) {
    const validation = validateSchema(options, 'request')
    if (validation.error) {
      throw new Error(validation.error)
    }

    const {
      forever,
      siteId,
      userId,
      action,
      client,
      index,
      body,
      id
    } = options
    let method = null
    let path = ''

    // Build request options for the given action
    switch (action) {
      case 'bulk':
        method = 'POST'
        path = '/bulk'
        break
      case 'create':
        method = 'POST'
        path = id ? `/${id}` : ''
        break
      case 'search':
        method = 'POST'
        path = '/search'
        break
      case 'mget':
        method = 'POST'
        path = '/mget'
        break
      case 'update':
        method = 'PUT'
        path = `/${id}`
        break
      case 'delete':
        method = 'DELETE'
        path = `/${id}`
        break
      case 'lookup':
        method = 'GET'
        path = `/${id}`
    }

    // Make request
    return got(`${SERVICE_ENDPOINT}/${index}${path}`, {
      method,
      body,
      headers: {
        'x-lucky-site-id': siteId,
        'x-lucky-uid': userId,
        'x-lucky-forever': Boolean(forever),
        'x-lucky-es-client': client || 'elassandra',
        'user-agent': `${pkg.name}/${pkg.version}`
      },
      json: true
    }).catch(error => {
      if (error.message) error.message = `[${pkg.name}] Request failed: ${error.message}`
      throw error
    })
  },

  /**
   * Returns a prettier version of an Elasticsearch hit object. Returns
   * the _source with _id as part of the source document.
   * @param  {Object} hit
   * @return {Object}
   */
  transformHit (hit) {
    hit._source.id = hit._id
    return hit._source
  }
}

module.exports = API
