#!/usr/bin/env node
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
const { program } = require('commander');
const execa = require('execa');
const Listr = require('listr');
const fs = require('fs-extra');
const addGlobals = require('../utils/add-globals');
const get = require('lodash/get');
const set = require('lodash/set');
const exitHook = require('exit-hook');
const getPort = require('get-port');
const readPkg = require('read-pkg');
const Case = require('case');
const { SecretManagerServiceClient } = require('@google-cloud/secret-manager');
program
    .version('2.0.0')
    .option('-m, --mode [String]', 'Running context: dev, prod, or test', 'dev')
    .option('-p, --project [String]', 'Name of Google Cloud Project', 'lucky-orange-staging');
const globals = addGlobals(program);
const options = program.opts();
// Clear console
process.stdout.write('\x1B');
// Process options
const config = globals.config;
let pkgName;
if (fs.existsSync('package.json')) {
    const pkg = readPkg.sync();
    pkgName = pkg.name.replace('@luckyorange/', '');
}
else if (fs.existsSync('go.mod')) {
    const goMod = fs.readFileSync('go.mod', 'utf8');
    for (const line of goMod.split('\n')) {
        if (line.startsWith('module ')) {
            const split = line.split('luckyorange/');
            pkgName = split[1];
            break;
        }
    }
}
else {
    console.error('No package.json or go.mod found. Exiting...');
    process.exit(1);
}
const mode = options.mode;
// Get start command
const parsed = program.parse(process.argv);
const startCmdArray = process.argv.slice(2);
const finalCommandArray = [...startCmdArray];
startCmdArray.forEach((value, index) => {
    if (parsed.options.find(o => o.short === value || o.long === value)) {
        finalCommandArray.splice(finalCommandArray.indexOf(value), 2);
    }
    else if (value === '--') {
        finalCommandArray.splice(finalCommandArray.indexOf(value), 1);
    }
});
const startCmd = finalCommandArray.join(' ');
// Build our task list
const tasks = new Listr([
    {
        title: 'Exposing desired services locally',
        skip: () => {
            if (mode !== 'dev') {
                return 'Not running in "dev" mode';
            }
            else if (config.start && config.start.services) {
                return false;
            }
            else {
                return 'No services provided';
            }
        },
        task: () => new Listr(config.start.services.map(service => {
            const gcloudOptions = `container clusters get-credentials ${service.cluster} --zone ${service.zone} --project ${service.project}`;
            let kubectlOptions = service.name === 'kubernetes' ? `proxy --port=${service.port}` : `port-forward ${service.name} ${service.port}`;
            if (service.namespace)
                kubectlOptions += ` --namespace=${service.namespace}`;
            return {
                title: service.name,
                task: (ctx, task) => {
                    return new Promise((resolve, reject) => __awaiter(void 0, void 0, void 0, function* () {
                        try {
                            // Connect to kubectl
                            task.output = `Connecting to kubernetes cluster: ${service.cluster}`;
                            yield execa('gcloud', gcloudOptions.split(' '));
                            // Port forward
                            task.output = `Forwarding port: ${service.port}`;
                            const kubeOutput = execa('kubectl', kubectlOptions.split(' '));
                            kubeOutput.catch(reject);
                            kubeOutput.stdout.on('data', data => {
                                if (data.includes('Forwarding from') ||
                                    data.includes('Starting to serve'))
                                    return resolve();
                            });
                        }
                        catch (error) {
                            reject(error);
                        }
                    }));
                }
            };
        }))
    },
    {
        title: 'Preparing to proxy requests',
        skip: () => __awaiter(void 0, void 0, void 0, function* () {
            const proxyPort = yield getPort({ port: 8002, host: 'localhost' });
            if (mode !== 'dev') {
                return 'Not running in "dev" mode';
            }
            else if (proxyPort !== 8002) {
                return 'Dev proxy already running';
            }
            else if (!get(config, 'start.kubernetes')) {
                return 'No kubernetes cluster provided';
            }
            else {
                return false;
            }
        }),
        task: (ctx, task) => __awaiter(void 0, void 0, void 0, function* () {
            return new Promise((resolve, reject) => __awaiter(void 0, void 0, void 0, function* () {
                const kubeConfig = config.start.kubernetes;
                const gcloudOptions = `container clusters get-credentials ${kubeConfig.cluster} --zone ${kubeConfig.zone} --project ${kubeConfig.project}`;
                task.output = `Connecting to kubernetes cluster: ${kubeConfig.cluster}`;
                yield execa('gcloud', gcloudOptions.split(' '));
                task.output = 'Ensuring dev-proxy is running';
                try {
                    const { stdout } = yield execa('kubectl', 'get pod dev-proxy'.split(' '));
                }
                catch (error) {
                    if (error.message.includes('NotFound')) {
                        task.output = 'Creating proxy deployment: dev-proxy';
                        yield execa('kubectl', 'run dev-proxy --image=hgascoigne/anyproxy:latest --wait=true --command -- anyproxy --intercept'.split(' '));
                    }
                }
                task.output = 'Forwarding port: 8001 8002';
                const kubeOutput = execa('kubectl', 'port-forward pod/dev-proxy 8001 8002'.split(' '));
                kubeOutput.catch(reject);
                kubeOutput.stdout.on('data', data => {
                    if (data.includes('Forwarding from') ||
                        data.includes('Starting to serve')) {
                        return resolve();
                    }
                });
            }));
        })
    },
    {
        title: 'Getting secrets',
        task: (ctx, task) => __awaiter(void 0, void 0, void 0, function* () {
            const env = {};
            // Check for service account if necessary
            if (options.project === 'lucky-orange' && process.env.GCLOUD_SERVICE_ACCOUNT_PROD) {
                fs.writeFileSync('./gcloud-service-account.json', process.env.GCLOUD_SERVICE_ACCOUNT_PROD);
            }
            else if (options.project === 'lucky-orange-staging' && process.env.GCLOUD_SERVICE_ACCOUNT_STAGING) {
                fs.writeFileSync('./gcloud-service-account.json', process.env.GCLOUD_SERVICE_ACCOUNT_STAGING);
            }
            // Scaffold secret manager client
            const nodeVersion = parseInt(process.version.split('.')[0].substring(1));
            const client = new SecretManagerServiceClient({
                fallback: nodeVersion <= 10
            });
            // Get list of secrets
            const [secrets] = yield client.listSecrets({
                parent: `projects/${options.project}`
            });
            // Get latest value for each secret
            const responses = yield Promise.all(secrets.map(secret => {
                return client.accessSecretVersion({
                    name: `${secret.name}/versions/latest`
                }).catch(error => {
                    if (error.message.includes('DISABLED')) {
                        return null;
                    }
                    else {
                        throw error;
                    }
                });
            }));
            // Add values to env object
            responses
                .filter(version => !!version)
                .forEach(([version], index) => {
                const key = secrets[index].name.split('/').slice(-1)[0];
                const payload = Buffer.from(version.payload.data).toString();
                env[key] = payload;
            });
            ctx.env = env;
        })
    },
    {
        title: 'Starting application',
        skip: () => startCmd ? false : 'No start command given',
        task: (ctx, task) => __awaiter(void 0, void 0, void 0, function* () {
            // Set up
            let desiredStartCmd = startCmd;
            const env = ctx.env;
            // Set lucky_dev if not in prod
            if (mode !== 'prod') {
                env.LUCKY_DEV = 1;
            }
            // Check if we're in dev mode
            if (mode === 'dev') {
                // Set proxy URL if needed
                if (get(config, 'start.kubernetes')) {
                    env.LUCKY_PROXY_URL = 'http://localhost:8001';
                }
                if (startCmd.includes('micro-dev')) {
                    // If using micro, set the port it should run on.
                    const microPort = yield getPort({ host: '127.0.0.1', port: getPort.makeRange(3000, 3100) });
                    const microCmd = startCmd.includes('micro-dev.js') ? 'micro-dev.js' : 'micro-dev';
                    desiredStartCmd = desiredStartCmd.replace(microCmd, `${microCmd} -p ${microPort} -H 127.0.0.1`);
                    // Allow @luckyorange/utilities-service-request to automatically send requests to local version of this service.
                    set(globals.globalState, `start.running.${pkgName}`, microPort);
                    globals.setGlobalState({
                        start: {
                            running: {
                                [pkgName]: microPort
                            }
                        }
                    });
                }
                // Set dev endpoints if needed
                Object
                    .entries(get(globals.globalState, 'start.running', {}))
                    .filter(([serviceName, port]) => !!port)
                    .forEach(([serviceName, port]) => {
                    env[`LO_${Case.constant(serviceName)}_ENDPOINT_DEV`] = `http://127.0.0.1:${port}`;
                });
            }
            // Run start command
            execa(desiredStartCmd, { stdio: 'inherit', env, shell: true })
                .then(result => {
                return process.exit(result.exitCode);
            })
                .catch(result => {
                return process.exit(result.exitCode);
            });
        })
    }
]);
// Run the tasks
tasks.run().then(() => {
    console.log('\n');
}).catch(() => {
    console.log('\n');
});
exitHook(() => {
    globals.setGlobalState({
        start: {
            running: {
                [pkgName]: false
            }
        }
    });
});
