import { HttpConnection, Client } from '@elastic/elasticsearch';
export { Client, Client as EsClient } from '@elastic/elasticsearch';
import SecretManager from '@luckyorange/secret-manager';

const endpointKeyMap = {
    forever: 'LO_EL_ENDPOINT_FOREVER',
    '30': 'LO_EL_ENDPOINT_30',
};
class ElasticSearch {
    static instance;
    secretManager;
    clients;
    constructor(secretManager) {
        this.clients = {};
        this.secretManager = secretManager;
    }
    static createInstance(secretManager) {
        if (!ElasticSearch.instance) {
            ElasticSearch.instance = new ElasticSearch(secretManager);
        }
        return ElasticSearch.instance;
    }
    static getInstance() {
        if (!ElasticSearch.instance) {
            ElasticSearch.createInstance(SecretManager.getInstance());
        }
        if (!ElasticSearch.instance) {
            throw new Error('ElasticSearch instance not initialized. Call createInstance first.');
        }
        return ElasticSearch.instance;
    }
    async initializeClients() {
        for (const key of Object.keys(endpointKeyMap)) {
            try {
                this.initializeClient(key);
            }
            catch (_error) { }
        }
        return this.clients;
    }
    async initializeClient(endpoint) {
        const endpointKey = endpointKeyMap[endpoint];
        if (!endpointKey)
            throw new Error(`no endpoint key for endpoint ${endpoint}`);
        try {
            const secretValue = await this.secretManager.getVar(endpointKey, {
                checkLocalProcess: true,
                checkRemote: true,
                addToCache: true,
            });
            if (!secretValue)
                throw new Error(`no secret value for key ${endpointKey}`);
            let parsedSecretValue = secretValue;
            if (typeof secretValue === 'string') {
                parsedSecretValue = JSON.parse(secretValue);
            }
            const config = Object.assign({
                requestTimeout: 60000,
                Connection: HttpConnection
            }, parsedSecretValue);
            if (config.cloud) {
                if (!config.auth) {
                    // @ts-expect-error This handles some backwards compatibility
                    config.auth = {};
                }
                // @ts-expect-error This handles some backwards compatibility
                if (config.cloud.username) {
                    // @ts-expect-error This handles some backwards compatibility
                    const username = config.cloud.username;
                    // @ts-expect-error This handles some backwards compatibility
                    // biome-ignore lint/performance/noDelete: <explanation>
                    delete config.cloud.username;
                    // @ts-expect-error This handles some backwards compatibility
                    config.auth.username = username;
                }
                // @ts-expect-error This handles some backwards compatibility
                if (config.cloud.password) {
                    // @ts-expect-error This handles some backwards compatibility
                    const password = config.cloud.password;
                    // @ts-expect-error This handles some backwards compatibility
                    // biome-ignore lint/performance/noDelete: <explanation>
                    delete config.cloud.password;
                    // @ts-expect-error This handles some backwards compatibility
                    config.auth.password = password;
                }
            }
            const client = new Client(config);
            this.clients[endpoint] = client;
            return client;
        }
        catch (error) {
            console.error(`error loading secret for key -  ${endpointKey}:`, error);
            throw error;
        }
    }
    async getClient(endpointKey) {
        let client = this.clients[endpointKey];
        if (!client) {
            client = await this.initializeClient(endpointKey);
        }
        return client;
    }
}

export { ElasticSearch, ElasticSearch as default };
//# sourceMappingURL=index.js.map
