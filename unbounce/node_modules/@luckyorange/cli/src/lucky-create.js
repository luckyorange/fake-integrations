#!/usr/bin/env node

const { program } = require('commander')
const Listr = require('listr')
const { prompt } = require('enquirer')
const chalk = require('chalk')
const execa = require('execa')
const path = require('path')
const copyTemplateDir = require('../utils/copy-template-directory')
const shell = require('shelljs')
const boxen = require('boxen')
const Case = require('case')
const cmdExists = require('command-exists').sync

async function create () {
  program
    .version('1.0.0')
    .parse(process.argv)

  // Get templates
  const templates = await require('./lucky-create-templates')()

  // Template options
  const options = await prompt([
    {
      type: 'select',
      name: 'template',
      message: 'What template would you like to use?',
      choices: Object.keys(templates)
    },
    {
      type: 'input',
      name: 'name',
      message () {
        return `What is the name of this ${this.enquirer.answers.template}?`
      },
      format: (value) => Case.kebab(value.toLowerCase()),
      result: (value) => Case.kebab(value.toLowerCase()),
      validate (value) {
        return !value ? 'Name is required' : true
      }
    },
    {
      type: 'input',
      name: 'description',
      message () {
        return `Would you like to give this ${this.enquirer.answers.template} a description?`
      },
      skip () {
        return templates[this.enquirer.answers.template].templateType !== 'project'
      }
    },
    {
      type: 'Form',
      name: 'cluster',
      message () {
        return `*Production* Cluster Information`
      },
      choices: [
        { name: 'name', message: 'Cluster', initial: 'api' },
        { name: 'zone', message: 'Zone', initial: 'us-central1-a' }
      ],

      skip () {
        return templates[this.enquirer.answers.template].templateType !== 'project'
      }
    },
    {
      type: 'Form',
      name: 'clusterStaging',
      message () {
        return `*Staging* Cluster Information`
      },
      choices: [
        { name: 'name', message: 'Cluster', initial: 'api' },
        { name: 'zone', message: 'Zone', initial: 'us-central1-c' }
      ],

      skip () {
        return templates[this.enquirer.answers.template].templateType !== 'project'
      }
    },
    {
      type: 'confirm',
      name: 'createRepo',
      message () {
        return `Would you like to create a new Github repo for this ${this.enquirer.answers.template}?`
      },
      initial: true,
      skip () {
        return templates[this.enquirer.answers.template].templateType !== 'project'
      }
    },
    {
      type: 'multiselect',
      name: 'features',
      message: 'What features should be added?',
      skip () {
        return !templates[this.enquirer.answers.template].features
      },
      initial () {
        const initial = templates[this.enquirer.answers.template].defaultFeatures
        this.options.initial = initial
        return initial
      },
      choices () {
        const choices = templates[this.enquirer.answers.template].features || [{ name: 'None', value: 'none' }]
        this.state._choices = choices
        return choices
      },
      result (choice) {
        const map = {}
        Object
          .values(this.map(choice))
          .forEach(value => {
            map[value] = true
          })

        return map
      }
    }
  ])

  const template = templates[options.template]
  const cwd = path.resolve(process.cwd(), template.templateType === 'project' ? `./${options.name}` : '')

  // Template creation steps
  const tasks = [
    {
      title: 'Creating project directory',
      enabled: () => template.templateType === 'project',
      task: () => shell.mkdir('-p', options.name)
    },
    {
      title: 'Creating GitHub repository',
      enabled: () => options.createRepo && template.templateType === 'project',
      task: async () => {
        if (!cmdExists('gh')) {
          throw new Error('GitHub CLI is required. Installation instructions: https://cli.github.com/manual/')
        }

        await execa('git config --global hub.protocol https', { shell: true })
        await execa('git init', { cwd, shell: true })
        await execa(`gh repo create luckyorange/${options.name} --private -d "${options.description}" --source ${cwd}`, { cwd, shell: true })
      }
    },
    {
      title: 'Creating project files',
      task: async () => {
        const data = typeof template.data === 'function' ? template.data(options) : template.data || {}

        const copyFrom = path.resolve(__dirname, './lucky-create-templates', template.inputDirectory)
        await copyTemplateDir(copyFrom, cwd, data)
      }
    }
  ]

  // Add any template defined scripts
  if (template.scripts) {
    template.scripts.forEach(script => {
      let scriptTask
      switch (script.type) {
        case 'function':
          scriptTask = {
            title: script.label,
            task: async () => {
              const data = typeof template.data === 'function'
                ? template.data(options)
                : template.hasOwnProperty('data')
                  ? template.data
                  : {}

              await script.value({
                cwd,
                data
              })
            }
          }
          break
        case 'bash':
        default:
          scriptTask = {
            title: script.label,
            task: () => execa(script.value, { cwd, shell: true })
          }
          break
      }
      tasks.push(scriptTask)
    })
  }

  const runner = new Listr(tasks)
  await runner.run()

  // Clear console
  process.stdout.write('\x1b')

  let message = ''

  if (template.templateType === 'project') {
    message = chalk.green(`Your ${options.template} "${options.name}" has been created!\n\n`)
    message += `Don't forget to run "cd ${options.name}" to start developing.\n`
    message += 'Learn more at https://docs.luckyorange.rocks/repos/cli'
  } else {
    message = chalk.green(`Your ${options.template} has been created!`)
  }

  console.log(boxen(message, {
    borderColor: 'green',
    margin: 1,
    padding: 1
  }))
}

create().catch(() => {})
